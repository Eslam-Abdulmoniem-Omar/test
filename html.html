<html><head><base href="https://example.com">
    <title>Example Domain</title>

    <meta charset="utf-8">
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
        
<style>
        [contenteditable="true"] {
          border: 1px dashed #666;
          padding: 2px;
          min-height: 1em;
          outline: none;
          transition: border-color 0.3s, background-color 0.3s;
        }
        [contenteditable="true"]:hover {
          border-color: #007bff;
          background-color: rgba(0, 123, 255, 0.1);
        }
        [contenteditable="true"]:focus {
          border-color: #007bff;
          background-color: rgba(0, 123, 255, 0.05);
        }
        .floating-edit-controls {
          position: fixed;
          background: rgba(0, 0, 0, 0.8);
          padding: 8px;
          border-radius: 4px;
          display: none;
          z-index: 10000;
          pointer-events: auto;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          transform: translate(-50%, -100%);
          margin-top: -10px;
        }
        .floating-edit-controls::after {
          content: '';
          position: absolute;
          bottom: -8px;
          left: 50%;
          transform: translateX(-50%);
          border-left: 8px solid transparent;
          border-right: 8px solid transparent;
          border-top: 8px solid rgba(0, 0, 0, 0.8);
        }
        .floating-edit-controls button {
          background: #007bff;
          color: white;
          border: none;
          padding: 4px 8px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          margin: 0 4px;
          pointer-events: auto;
        }
        .floating-edit-controls button:hover {
          background: #0056b3;
        }
        .editable-image {
          cursor: pointer;
          transition: outline 0.2s;
        }
        .editable-image:hover {
          outline: 2px solid #007bff;
          outline-offset: 2px;
        }
        .image-edit-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          background: rgba(0, 0, 0, 0.7);
          padding: 8px;
          display: none;
          justify-content: center;
          gap: 8px;
          z-index: 10000;
          pointer-events: auto;
        }
        .image-container {
          position: relative !important;
          display: inline-block !important;
          width: auto !important;
          height: auto !important;
          margin: 0 !important;
          padding: 0 !important;
          vertical-align: top !important;
          pointer-events: auto;
        }
        .image-container:hover .image-edit-overlay {
          display: flex;
          opacity: 1;
        }
        .image-edit-button {
          background: #007bff;
          border: none;
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          z-index: 10001;
          pointer-events: auto;
        }
        .image-edit-button:hover {
          background: #0056b3;
        }
        .image-container img {
          display: inline-block !important;
          width: auto !important;
          height: auto !important;
          max-width: none !important;
          margin: 0 !important;
          padding: 0 !important;
          pointer-events: none;
        }
        .resize-handle {
          width: 16px;
          height: 16px;
          background: #007bff;
          position: absolute;
          right: -8px;
          bottom: -8px;
          cursor: se-resize;
          border-radius: 50%;
          display: none;
          z-index: 101;
          border: 2px solid white;
          box-shadow: 0 0 4px rgba(0,0,0,0.3);
        }
        .image-container:hover .resize-handle {
          display: block;
        }
        #save-controls {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 10000;
        }
        #save-button {
          padding: 10px 20px;
          background-color: #28a745;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          font-size: 14px;
          display: none;
          transition: background-color 0.3s;
        }
        #save-button:hover {
          background-color: #218838;
        }
        #save-button.visible {
          display: block;
        }
        #save-notification {
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 10px 20px;
          background-color: #28a745;
          color: white;
          border-radius: 5px;
          z-index: 10000;
          display: none;
          animation: fadeInOut 2s ease-in-out forwards;
        }
        @keyframes fadeInOut {
          0% { opacity: 0; transform: translateY(-20px); }
          15% { opacity: 1; transform: translateY(0); }
          85% { opacity: 1; transform: translateY(0); }
          100% { opacity: 0; transform: translateY(-20px); }
        }
      </style><style>
    body {
        background-color: #f0f0f2;
        margin: 0;
        padding: 0;
        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
        
    }
    div {
        width: 600px;
        margin: 5em auto;
        padding: 2em;
        background-color: #fdfdff;
        border-radius: 0.5em;
        box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);
    }
    a:link, a:visited {
        color: #38488f;
        text-decoration: none;
    }
    @media (max-width: 700px) {
        div {
            margin: 0 auto;
            width: auto;
        }
    }
    </style></head>

<body>
<div>
    <h1 contenteditable="true" data-original="Example Domain" data-editable="true" data-path="html > body > div > h1">Example Domain</h1>
    <p contenteditable="true" data-original="This domain is for use in illustrative examples in documents. You may use this
    domain in literature without prior coordination or asking for permission." data-editable="true" data-path="html > body > div > p">This domain is for use in illustrative examples in documents. You may use this
    domain in literature without prior coordination or asking for permission.</p>
    <p contenteditable="true" data-original="<a href=&quot;https://www.iana.org/domains/example&quot;>More information...</a>" data-editable="true" data-path="html > body > div > p:nth-of-type(2)"><a href="https://www.iana.org/domains/example">More information...</a></p>
</div>


<div id="save-controls" data-editable="false"><button id="save-button" data-editable="false">Save Changes</button></div><div id="save-notification" data-editable="false">Changes saved!</div><script>
        document.addEventListener('DOMContentLoaded', function() {
          const saveButton = document.getElementById('save-button');
          const notification = document.getElementById('save-notification');
          let hasUnsavedChanges = false;
          let isDeleteMode = false;

          // Create delete mode toggle button
          const deleteToggle = document.createElement('button');
          deleteToggle.textContent = 'Toggle Delete Mode';
          deleteToggle.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 165px;
            z-index: 111111;
            background: red;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
          `;
          document.body.appendChild(deleteToggle);

          function enableDeleteMode() {
            document.body.addEventListener("mouseover", highlightElement);
            document.body.addEventListener("mouseout", removeHighlight);
            document.body.addEventListener("click", handleDelete);
            document.body.style.cursor = 'crosshair';
            isDeleteMode = true;
            deleteToggle.style.backgroundColor = 'darkred';
          }

          function disableDeleteMode() {
            document.body.removeEventListener("mouseover", highlightElement);
            document.body.removeEventListener("mouseout", removeHighlight);
            document.body.removeEventListener("click", handleDelete);
            document.body.style.cursor = 'default';
            isDeleteMode = false;
            deleteToggle.style.backgroundColor = 'red';
            
            // Clean up any remaining highlights
            document.querySelectorAll('[data-delete-highlight]').forEach(el => {
              el.style.outline = '';
              delete el.dataset.deleteHighlight;
            });
          }

          function highlightElement(e) {
            const target = e.target;
            if (!target.dataset.deleteHighlight && target !== deleteToggle) {
              target.dataset.deleteHighlight = true;
              target.style.outline = "2px dashed red";
              target.title = "Click to delete this element";
            }
          }

          function removeHighlight(e) {
            const target = e.target;
            if (target.dataset.deleteHighlight && target !== deleteToggle) {
              target.style.outline = "";
              delete target.dataset.deleteHighlight;
              target.title = "";
            }
          }

          function handleDelete(e) {
            const target = e.target;
            if (target.dataset.deleteHighlight && target !== deleteToggle) {
              e.preventDefault();
              e.stopPropagation();
              
              if (confirm("Are you sure you want to delete this element?")) {
                target.remove();
                hasUnsavedChanges = true;
                if (saveButton) {
                  saveButton.classList.add('visible');
                }
                showNotification('Element deleted!', false);
              }
            }
          }

          // Toggle delete mode
          deleteToggle.addEventListener('click', () => {
            if (isDeleteMode) {
              disableDeleteMode();
              showNotification('Delete mode disabled', false);
            } else {
              enableDeleteMode();
              showNotification('Delete mode enabled - Click elements to delete them', false);
            }
          });

          function showNotification(message = 'Changes saved!', isError = false) {
            notification.textContent = message;
            notification.style.backgroundColor = isError ? '#dc3545' : '#28a745';
            notification.style.display = 'block';
            setTimeout(() => {
              notification.style.display = 'none';
            }, 2000);
          }

          function isValidHTML(html) {
            try {
              const doc = new DOMParser().parseFromString(html, 'text/html');
              return Array.from(doc.body.childNodes).every(node => 
                node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE
              );
            } catch (error) {
              console.error('HTML validation error:', error);
              return false;
            }
          }

          function handleChange(event) {
            const element = event.target;
            if (!element.hasAttribute('data-editable')) return;

            const newContent = element.innerHTML;
            if (!isValidHTML(newContent)) {
              console.warn('Invalid HTML content detected');
              element.innerHTML = element.getAttribute('data-original');
              showNotification('Invalid content. Changes reverted.', true);
              return;
            }

            hasUnsavedChanges = true;
            saveButton.classList.add('visible');
          }

          // Prevent link clicks while editing
          document.addEventListener('click', function(e) {
            if (e.target.closest('[contenteditable="true"]')) {
              const clickedElement = e.target.closest('a') || e.target.closest('button');
              if (clickedElement) {
                e.preventDefault();
                e.stopPropagation();
              }
            }
          }, true);

          function saveChanges() {
            try {
              const savedContent = {};
              let hasChanges = false;

              // Collect all edited elements
              document.querySelectorAll('[data-editable="true"]').forEach(element => {
                try {
                  const path = element.getAttribute('data-path');
                  const originalContent = element.getAttribute('data-original');
                  const currentContent = element.innerHTML;

                  if (!path) {
                    console.warn('Element missing data-path attribute:', element);
                    return;
                  }

                  if (currentContent !== originalContent) {
                    if (!isValidHTML(currentContent)) {
                      throw new Error('Invalid HTML content detected');
                    }

                    hasChanges = true;
                    savedContent[path] = {
                      content: currentContent,
                      timestamp: new Date().toISOString()
                    };
                    // Update the original content to reflect saved state
                    element.setAttribute('data-original', currentContent);
                  }
                } catch (elementError) {
                  console.error('Error processing element:', elementError);
                  throw new Error('Failed to process edited content');
                }
              });

              if (!hasChanges) {
                showNotification('No changes to save!');
                return;
              }




 // Remove editable-image class and hover effects
    document.querySelectorAll('.editable-image').forEach(img => {
      img.classList.remove('editable-image');
      const container = img.closest('.image-container');
      if (container) {
        container.style.pointerEvents = 'none';
      }
    });








              // Create a new clone of the current page with all changes
              const clone = document.documentElement.cloneNode(true);

              // Remove the save controls from the cloned version
              const clonedSaveControls = clone.querySelector('#save-controls');
              if (clonedSaveControls) clonedSaveControls.remove();

              const clonedNotification = clone.querySelector('#save-notification');
              if (clonedNotification) clonedNotification.remove();

              // Remove contenteditable and other editing attributes
              clone.querySelectorAll('[data-editable="true"]').forEach(element => {
                element.removeAttribute('contenteditable');
                element.removeAttribute('data-editable');
                element.removeAttribute('data-original');
                element.removeAttribute('data-path');
              });

              // Create and trigger download
              const blob = new Blob([clone.outerHTML], { type: 'text/html;charset=utf-8' });
              const url = URL.createObjectURL(blob);

              showNotification('Preparing download with your changes...');

              // Check if we're in Chrome extension context
              if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.sendMessage) {
                chrome.runtime.sendMessage({
                  action: "download",
                  url: url,
                  filename: `edited-page-${new Date().toISOString().replace(/[:.]/g, "-")}.html`
                }, (response) => {
                  if (chrome.runtime.lastError) {
                    console.error('Chrome runtime error:', chrome.runtime.lastError);
                    // Fallback to direct download if extension fails
                    triggerDirectDownload(url);
                    return;
                  }

                  // Reset the edit state
                  hasUnsavedChanges = false;
                  saveButton.classList.remove('visible');

                  // Show success notification after small delay
                  setTimeout(() => {
                    showNotification('Changes saved and new page downloaded!');
                  }, 500);
                });
              } else {
                // Direct download for non-extension context
                triggerDirectDownload(url);
              }

              // Remove editable classes from cloned version
    clone.querySelectorAll('.editable-image').forEach(img => {
      img.classList.remove('editable-image');
      const container = img.closest('.image-container');
      if (container) {
        container.style.pointerEvents = 'none';
      }
    });

            } catch (error) {
              console.error('Error saving changes:', error);
              showNotification(`Error saving changes: ${error.message}`, true);
            }
          }

          // Helper function for direct downloads
          function triggerDirectDownload(url) {
            const a = document.createElement('a');
            a.href = url;
            a.download = `edited-page-${new Date().toISOString().replace(/[:.]/g, "-")}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Reset state and show success
            hasUnsavedChanges = false;
            saveButton.classList.remove('visible');
            setTimeout(() => {
              showNotification('Changes saved and new page downloaded!');
            }, 500);
          }

          // Setup image editing
          function setupImageEditing() {
            const floatingControls = document.createElement('div');
            floatingControls.className = 'floating-edit-controls';

            const replaceBtn = document.createElement('button');
            replaceBtn.textContent = 'Replace Image';
            floatingControls.appendChild(replaceBtn);

            document.body.appendChild(floatingControls);

            let activeImage = null;
            let isEditControlsVisible = false;

            // Function to handle image replacement
          function handleImageReplace(img) {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.style.display = 'none'; // Keep the input hidden

  input.addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function (e) {
        // Store original dimensions and styles
        const originalWidth = img.width;
        const originalHeight = img.height;
        const computedStyle = window.getComputedStyle(img);

        // Update image source with the uploaded image
        img.src = e.target.result;

        // Restore original dimensions and styles
        img.width = originalWidth;
        img.height = originalHeight;
        img.style.cssText = computedStyle.cssText; // Copy all styles

        // Indicate unsaved changes (optional feature)
        const saveButton = document.getElementById('save-button');
        if (saveButton) {
          hasUnsavedChanges = true;
          saveButton.classList.add('visible');
        }
      };
      reader.readAsDataURL(file); // Convert the image to Base64
    }
  });

  // Trigger the file input dialog
  document.body.appendChild(input);
  input.click();
  document.body.removeChild(input);
}

const images = document.querySelectorAll('img');
images.forEach((img) => {
  img.addEventListener('click', () => handleImageReplace(img));
    img.removeAttribute('srcset');

});

            // Handle mouse events for showing/hiding controls
            document.addEventListener('mouseover', function(e) {
              const img = e.target.closest('img:not([data-no-edit])');
              if (img) {
                activeImage = img;
                img.classList.add('editable-image');

                // Position controls above the mouse cursor
                const updateControlsPosition = (e) => {
                  if (activeImage === img) {
                    floatingControls.style.display = 'block';
                    floatingControls.style.left = e.pageX + 'px';
                    floatingControls.style.top = e.pageY + 'px';
                    isEditControlsVisible = true;
                  }
                };

                updateControlsPosition(e);
                img.addEventListener('mousemove', updateControlsPosition);
              }
            });

            document.addEventListener('mouseout', function(e) {
              const img = e.target.closest('img:not([data-no-edit])');
              if (img) {
                // Check if mouse is over the controls
                const relatedTarget = e.relatedTarget;
                if (!floatingControls.contains(relatedTarget)) {
                  floatingControls.style.display = 'none';
                  isEditControlsVisible = false;
                  img.removeEventListener('mousemove', updateControlsPosition);
                }
              }
            });

            // Handle replace button click
            replaceBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              if (activeImage) {
                handleImageReplace(activeImage);
              }
            });

            // Hide controls when clicking outside
            document.addEventListener('click', function(e) {
              if (!e.target.closest('.floating-edit-controls') && !e.target.closest('img:not([data-no-edit])')) {
                floatingControls.style.display = 'none';
                isEditControlsVisible = false;
                if (activeImage) {
                  activeImage.classList.remove('editable-image');
                  activeImage = null;
                }
              }
            });

            // Mark all images as editable initially
            document.querySelectorAll('img').forEach(img => {
              if (!img.hasAttribute('data-no-edit')) {
                img.classList.add('editable-image');
              }
            });
          }

          document.addEventListener('input', handleChange);
          saveButton.addEventListener('click', saveChanges);
          setupImageEditing();

          window.addEventListener('beforeunload', function(e) {
            if (hasUnsavedChanges) {
              e.preventDefault();
              e.returnValue = '';
            }
          });
        });
      </script></body></html>